<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">



  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">







  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="VIALrZmY0YkH9jPNkDh1Zr9MPGhCK8kJAu3wwHlInLU" />




















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言近两月公司项目少，主要精力都放在 HAL1 到 HAL3 的业务迁移学习中。花了蛮多时间看代码，也试着写了 Open Camera 的流程分析文档，发在了我的 CSDN 博客里。 当然整天只能看看看看看代码，是真的很容易觉得枯燥的。即便是对 Google 和 QCom 的这些比较赏心悦目的代码风格来说，连续看两三个小时也是会开始心不在焉的。于是我搬出了大四时候买的《Effective C++》">
<meta name="keywords" content="编程技术,温故知新">
<meta property="og:type" content="article">
<meta property="og:title" content="[多读好书]《Effective C++》回顾">
<meta property="og:url" content="http://StoneAndFish.cn/2018/09/13/EffectiveC-1st/index.html">
<meta property="og:site_name" content="石锅鱼的锅">
<meta property="og:description" content="前言近两月公司项目少，主要精力都放在 HAL1 到 HAL3 的业务迁移学习中。花了蛮多时间看代码，也试着写了 Open Camera 的流程分析文档，发在了我的 CSDN 博客里。 当然整天只能看看看看看代码，是真的很容易觉得枯燥的。即便是对 Google 和 QCom 的这些比较赏心悦目的代码风格来说，连续看两三个小时也是会开始心不在焉的。于是我搬出了大四时候买的《Effective C++》">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2019/09/08/hDe3mRoG4VgB8qF.jpg">
<meta property="og:updated_time" content="2019-09-08T08:10:18.813Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[多读好书]《Effective C++》回顾">
<meta name="twitter:description" content="前言近两月公司项目少，主要精力都放在 HAL1 到 HAL3 的业务迁移学习中。花了蛮多时间看代码，也试着写了 Open Camera 的流程分析文档，发在了我的 CSDN 博客里。 当然整天只能看看看看看代码，是真的很容易觉得枯燥的。即便是对 Google 和 QCom 的这些比较赏心悦目的代码风格来说，连续看两三个小时也是会开始心不在焉的。于是我搬出了大四时候买的《Effective C++》">
<meta name="twitter:image" content="https://i.loli.net/2019/09/08/hDe3mRoG4VgB8qF.jpg">



  <link rel="alternate" href="/atom.xml" title="石锅鱼的锅" type="application/atom+xml" />




  <link rel="canonical" href="http://StoneAndFish.cn/2018/09/13/EffectiveC-1st/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>[多读好书]《Effective C++》回顾 | 石锅鱼的锅</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116662706-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-116662706-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3f1d459f8c3f4712ad70e6a7b8c510e7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">石锅鱼的锅</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://StoneAndFish.cn/2018/09/13/EffectiveC-1st/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StoneDemo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/Second_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="石锅鱼的锅">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">[多读好书]《Effective C++》回顾</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-13T20:01:49+08:00">2018-09-13</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近两月公司项目少，主要精力都放在 HAL1 到 HAL3 的业务迁移学习中。花了蛮多时间看代码，也试着写了 Open Camera 的流程分析文档，发在了<a href="https://blog.csdn.net/qq_16775897" target="_blank" rel="noopener">我的 CSDN 博客</a>里。</p>
<p>当然整天只能看看看看看代码，是真的很容易觉得枯燥的。即便是对 Google 和 QCom 的这些比较赏心悦目的代码风格来说，连续看两三个小时也是会开始心不在焉的。于是我搬出了大四时候买的《Effective C++》，开始（在看腻了代码的时候）慢慢啃了起来。<br><a id="more"></a></p>
<p>刚买这本书的时候，我也是啃过一部分的，但是只是很小一部分，大概只是看到了第二章。那时候学习效率不高，自己的代码实践经验也少之又少，难以体会作者所描述的细节，看书的时候感觉无法提炼出核心内容，仿佛每一个字都是重点一般。</p>
<p>到了现在，工作一年有余，有了一些实践经验，看过、分析了不少出自 Google、QCom 工程师之手的优秀代码，再来看看书中的内容，果然理解起来顺畅了许多！</p>
<p>目前第一遍的学习已经接近尾声，学习过程中的各种笔记都记在了纸质的本子上，懒得一一搬到电脑中了…现在一直在尝试将笔记做成思维导图这种类型的样子，感觉这样在阅读时更能够驱动自己把握好细节，然后提取出核心思想。慢慢改进了两三个月，感觉自己的读书效率，听培训、课程时的笔记效率都有非常大的提升。</p>
<p><img src="https://i.loli.net/2019/09/08/hDe3mRoG4VgB8qF.jpg" alt="EFC__笔记样例.jpg"></p>
<p>这一趟阅读下来收获颇丰，但这其中我也发现，还有相当一部分内容依旧难以理解，其原因大致如下：</p>
<ul>
<li>一是自身的实践经验还是有所欠缺，覆盖面还不够广；</li>
<li>二是我对 C++ 的理解还不够深刻，对其知识点的掌握程度还不够高（特别是对 C++11、C++14 等的新增特性知之甚少，也不常使用）。</li>
</ul>
<p>所以接下来我需要花一些时间回顾这段时间的阅读内容，看看哪些条目我已经有了比较清晰的理解，还有哪些需要继续深入学习。一方面是要进行总结，尽可能吸收知识，另一方面则是要为以后的第二遍更针对性的阅读指出方向。</p>
<p><strong>NOTE：个人认为，《Effective C++》是一本工具书，它需要与具体工程紧密结合，而如果脱离工程、实践去阅读它，则会非常浪费时间！在实践的过程中进行阅读、应用，或者在具有一定量的实践经验时再来阅读，方能体现其真正的价值，学到精华之所在。</strong></p>
<h1 id="温故而知新"><a href="#温故而知新" class="headerlink" title="温故而知新"></a>温故而知新</h1><h2 id="第一章-「让自己习惯-C-」"><a href="#第一章-「让自己习惯-C-」" class="headerlink" title="第一章 「让自己习惯 C++」"></a>第一章 「让自己习惯 C++」</h2><p>本章内容为条款 1~4，作者认为这几个条款是「总有那么一些东西比其它的更基础些」的那一部分，先来回顾回顾它们的标题：</p>
<ol>
<li><p><strong>视 C++ 为一个语言联邦。</strong></p>
<blockquote>
<p>View C++ as a federation of languages.</p>
</blockquote>
</li>
<li><p><strong>尽量以「const / enum / inline」替换「#define」。</strong></p>
<blockquote>
<p>Prefer consts, enums, and inlines to #define.</p>
</blockquote>
</li>
<li><p><strong>尽可能使用「const」。</strong></p>
<blockquote>
<p>Use const whenever possible.</p>
</blockquote>
</li>
<li><p><strong>确定对象被使用前已被初始化。</strong></p>
<blockquote>
<p>Make sure that objects are initialized before they’re used.</p>
</blockquote>
</li>
</ol>
<p>C++ 是基于 C 语言而扩展出来的，庞大而混杂 —— 它现在已经是一个<strong>「多重泛型编程语言」</strong>，它同时支持「过程形式」、「面向对象形式」、「函数形式」、「泛型形式」，以及「元编程形式」。这些能力与弹性让 C++ 像一个装满了各式各样的工具的箱子一样，任何问题都能通过使用其中的一部分工具来高效地解决，虽然看起来笨重了点。</p>
<p>而前人从无数的编程实践中总结出了一些编码守则，这些守则或能使我们更高效地编写代码，或能使我们的代码效率提高数个层级，更甚者两者兼具。但这些守则在 C++ 世界中不是放之四海而皆准的，我们需要在适当的部位运用恰当的工具，于是作者认为，我们需要将 C++ 视为一个<strong>「语言联邦」</strong>，这其中包括四大部分：「C」、「面向对象的 C++」、「STL」，以及「C++ 模板」。</p>
<p>高效守则需要根据不同的联邦而采用不同的方法。</p>
<p>相比起 C，C++ 中扩展了 <code>const</code>、<code>inline</code> 等等有意思的关键字。在纯 C 中，我们经常能看到大量的宏定义 <code>#define</code> 语句，用它来定义一些常量有时候确实能让代码更清晰，但用来定义一些函数就常常让人看得脑壳疼。更难受的是，使用它的时候需要非常极其小心翼翼，少一组括号可能就会导致代码在某些神秘的情况下出现 Bug，并且难以追踪调试。而在 C++ 中我们可以用 <code>const</code> 来表明常量，它使我们能够在编译期就发现关于常量的误用问题。<code>inline</code> 则可以用来定义函数，这些函数编译时也会进行相应的展开，与宏定义的效果是一样的，而它还能够提供封装性。</p>
<p><code>const</code> 关键字有很多用途，当我们需要各种意义上的「不可改变的常量」时，它就能发挥作用。值得注意的是，它不仅在定义变量时能派上用场，在定义函数时也有它的身影。</p>
<p>在日常撸代码时，我就经常忘记给某些变量进行初始化赋值，于是运行程序时它们获得了一个伪随机值，导致程序流程都乱了套。看来这是程序员们共同的经历，而这一历史直到今天也在不断重演…以至于作者要将它作为「最基本的」几个条款之一，不得不说，<strong>确保初始化真的很很很重要！</strong></p>
<p>第一章的内容中，应该说并没有什么疑难点。如果说需要进一步学习的话，或许应该关注第二条，好好理解一下各个替换宏的关键字的使用时机吧。</p>
<h2 id="第二章-「构造、析构、赋值运算」"><a href="#第二章-「构造、析构、赋值运算」" class="headerlink" title="第二章 「构造、析构、赋值运算」"></a>第二章 「构造、析构、赋值运算」</h2><p>本章详细解释了条款 5~12，主要关乎一个类的几个重点组成成分，即构造函数、析构函数、拷贝构造函数和赋值运算符。先回顾回顾它们的标题：</p>
<ol>
<li><p><strong>了解 C++ 默默编写并调用了哪些函数。</strong></p>
<blockquote>
<p>Know what function C++ silently writes and calls.</p>
</blockquote>
</li>
<li><p><strong>若不想使用编译器自动生成的函数，就应该明确拒绝。</strong></p>
<blockquote>
<p>Explicitly disallow the use of compiler-generated functions you do not want.</p>
</blockquote>
</li>
<li><p><strong>为多态基类声明「virtual 析构函数」。</strong></p>
<blockquote>
<p>Declare destructors virtual in polymorphic base classes.</p>
</blockquote>
</li>
<li><p><strong>别让异常逃离析构函数。</strong></p>
<blockquote>
<p>Prevent exceptions from leaving destructors.</p>
</blockquote>
</li>
<li><p><strong>绝不在构造和析构过程中调用「virtual 函数」。</strong></p>
<blockquote>
<p>Never call virtual functions during construction or desturction.</p>
</blockquote>
</li>
<li><p><strong>令「operator=」返回一个「<em>reference to \</em>this*」。</strong></p>
<blockquote>
<p>Have assignment operators return a reference to *this.</p>
</blockquote>
</li>
<li><p><strong>在「operator=」中处理「自我赋值」。</strong></p>
<blockquote>
<p>Handle assignment to self in operator=.</p>
</blockquote>
</li>
<li><p><strong>复制对象时勿忘其每一个成分。</strong></p>
<blockquote>
<p>Copy all parts of an object.</p>
</blockquote>
</li>
</ol>
<p>当我们编写了一个「空类」，C++ 编译器有可能（当我们的代码中存在相应逻辑）会自动地为它创建默认的「构造函数」、「析构函数」、「拷贝构造函数」和「operator=」。这些默认函数都是 <code>public</code> 且 <code>inline</code> 的。</p>
<p>有时候这些被偷偷创建出来的函数会扰乱我们的代码逻辑，比如说我们设计的类是「独一无二的」，那就不允许它进行拷贝构造，但默认拷贝构造的存在让逻辑变得混乱。编码时我们就需要考虑到这一层，从而判断是否需要明确拒绝生成默认函数。明确拒绝生成的方法可以是将相应函数声明为 <code>private</code> 且不予实现，也可以是利用 <code>Uncopyable</code> 这样的特殊基类。</p>
<p>在这些默认函数中，有一个需要特殊注意的就是「析构函数」：</p>
<ul>
<li>如果我们设计的是一个具有多态性质的类，或者我们的类中有任意一个 <code>virtual</code> 函数，我们都应该将析构函数声明为 <code>virtual</code>，否则可能会在使用指针、引用时出现诡异的「局部销毁」问题。</li>
<li>析构函数绝不要抛出异常，这样会导致程序异常中断或者产生不明确的行为。我们可以提供一个普通函数来执行那些可能会抛出异常的操作（从而给调用者一个率先处理异常的机会），而析构中也会调用该函数（当调用者忽略了它）来保证逻辑完整，但在析构中出现的异常，我们要将其吞没或者直接结束程序。</li>
</ul>
<p>而「构造函数 / 拷贝构造函数」以及「析构函数」都需要注意的一点，就是不要在它们的内部调用 virtual 函数（如果期望调用到子类的实现的话）。这一点其实很好理解，构造时先构造的父类，彼时子类还未生成，怎能调用子类的实现呢？而析构时则是先销毁了子类，当然也就不能再调用子类的实现了。</p>
<p>「operator=」就是赋值操作符，关于它也有一些需要注意的点：</p>
<ul>
<li>让它的返回值是一个对 <code>this</code> 指针的引用，这样才能确保 <code>x = y = z</code> 这样的语句是正确的。同样的道理也适用于「+」，「-」等其它操作符。</li>
<li>要考虑到「自我赋值」的情况（「别名」的存在导致这种情况并不少见），确保这一行为的安全性（主要保证其「异常安全性」）。相关的处理技术有「证同测试」、「精心设计的语句顺序」以及「Copy-and-Swap」。</li>
</ul>
<p>拷贝构造与赋值运算其实非常类似，都是关于「复制」这一逻辑。它们两通常有着高度一致的逻辑，我们可以将逻辑一致的部分转移到一个新的函数中，但不要让它们两之间存在调用关系。同时在「复制」的时候，我们必须要注意别忘了将类中的「每一个」成分都复制过去，在实践时经常会有「往类中添加成员变量」这种情况，这时候我们就需要确保这些成员的更新在「成员初值列」以及「复制操作」中体现出来。</p>
<p>总的来说，第二章的内容也是相当地基础，在日常的编码实践和代码阅读中就能很好地体会到这些守则的妙处。要说以后还需要继续深入理解的部分，应该是关于析构与异常的处理，这部分的情况可能在数据库、网络会话之类的场景经常出现，不过我目前都没有怎么接触过。</p>
<h2 id="第三章-「资源管理」"><a href="#第三章-「资源管理」" class="headerlink" title="第三章 「资源管理」"></a>第三章 「资源管理」</h2><p>到了第三章，我感觉就开始进入了一个进阶部分。资源管理在实际工程中非常重要，资源的分配与回收是 C++ 中的一个大问题，因为我们常常会采用「动态分配内存」的方式来获取资源，如果不及时回收资源，则会造成内存泄露之类的问题。作者总结出了条款 13~17 用以最大限度地避免资源相关问题的出现，先来复习一下，它们分别是什么：</p>
<ol>
<li><p><strong>以对象管理资源。</strong></p>
<blockquote>
<p>Use objects to manage resource.</p>
</blockquote>
</li>
<li><p><strong>在资源管理类中小心「copy 行为」。</strong></p>
<blockquote>
<p>Think carefully about copying behavior in resource-managing classes.</p>
</blockquote>
</li>
<li><p><strong>在资源管理类中提供对原始资源的访问。</strong></p>
<blockquote>
<p>Provider access to raw resources in resource-managing classes.</p>
</blockquote>
</li>
<li><p><strong>成对使用「new」和「delete」时要采取相同形式。</strong></p>
<blockquote>
<p>Use the same form in corresponding uses of new and delete.</p>
</blockquote>
</li>
<li><p><strong>以独立语句将「new 出来的」对象置入只能指针内。</strong></p>
<blockquote>
<p>Store newed objects in smart pointers in standalone statements.</p>
</blockquote>
</li>
</ol>
<p>在开发应用程序时，我们肯定会编写一大堆函数。而在函数中通过 <code>malloc</code> 或者 <code>new</code> 申请出一块内存，这个场景对于 C++ 开发者来说，真是再熟悉不过了。然而，申请出来的内存要在何时何地释放？初学者常常忽略这个问题，甚至一些经验丰富的开发者有时也会被这个问题困扰。我们通常会在函数的末尾对相关内存进行回收，让其保持与函数相应的生命周期，但经常会出现的问题是「在函数内增减分支、逻辑时，出现新的函数结束点，但此处没有进行资源回收」。</p>
<p>为了防止资源泄露，前人设计了一众「RAII（Resource Acquisition Is Initialization）类」作为资源管理类。这种对象在构造函数中获得资源，并且在析构函数中进行资源释放。而对象的生命周期和函数保持一致，这就使得资源回收得到一定的保证。C++ 中常用的 RAII 对象有 <code>shared_ptr</code> 以及 <code>auto_ptr</code>，前者通常比较好用，因为它的拷贝行为比较直观（后者的拷贝动作会导致被复制物指向 <code>null</code>）。</p>
<p>说到 RAII 类对象的拷贝问题，作者也提出了一些需要注意的事项：</p>
<ul>
<li>拷贝 RAII 对象必须一并拷贝其资源，所以资源的拷贝行为决定了 RAII 对象的拷贝行为。</li>
<li>常见的复制行为有：「抑制拷贝」、「采用引用计数法」。也有一些其它技术，但未提及。</li>
</ul>
<p>理想状况下，API 不应该对原始资源有访问需求。但是现实往往是残酷的，不是每个 API 设计者都奉行这一理念，所以许多 APIs 还是会要求访问原始资源。于是乎每个 RAII 类都需要提供一个「取得其管理的原始资源」的方法，一般是给出一个 <code>get()</code> 函数获取原始资源指针，在 Android 底层使用强指针类 <code>sp</code> 时经常用到这一方法。需要注意的是，访问原始资源可能会经过显示或隐式的转换，一般来说提供显式转换比较安全，但是提供隐式转换对客户来说就比较方便。</p>
<p>众所周知，<code>new</code> 与 <code>delete</code> 成对使用，而 <code>malloc</code> 与 <code>free</code> 成对使用。但作者提醒我们，还需要注意的是，「<code>new[]</code> 与 <code>delete[]</code> 成对」，「<code>new</code> 与 <code>delete</code> 成对」，如果 <code>[]</code> 这个符号用混了，可能会导致不明确行为或者资源泄露。</p>
<p>接下来考虑一个情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(share_ptr(<span class="keyword">new</span> A), f());</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，执行函数 <code>func</code> 时可能出现的一个顺序：</p>
<ol>
<li><code>new A</code></li>
<li><code>f()</code></li>
<li><code>share_ptr()</code></li>
</ol>
<p>注意第 2 步骤，若其内部会抛出异常，就会导致第 3 步不执行，此情况下资源 A 就会泄露。</p>
<p>所以我们应该用一个独立语句将 <code>new</code> 出来的对象存储到 RAII 类对象中，就像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A);</span><br><span class="line">func(pa, f());</span><br></pre></td></tr></table></figure>
<p>从而保证避免那些难以察觉的资源泄露情况。</p>
<p>本章中介绍的诸多内容，在阅读 Android 底层源码时我就已经有所体会，但还没有多少机会亲自设计、实践。一趟回顾下来，发现理解不够深入的是条款 14，在下一轮阅读中需要特别关注。</p>
<h2 id="第四章-「设计与声明」"><a href="#第四章-「设计与声明」" class="headerlink" title="第四章 「设计与声明」"></a>第四章 「设计与声明」</h2><p>第四章开始进入更复杂的接口设计部分，这一部分中作者总结出了几个关于优良接口设计的关键点，当然在实战中还有更多需要注意的点，但作者提出的这些也能够让我们大大提高编码效率以及正确性。第 18~25 条款标题如下：</p>
<ol>
<li><p><strong>让接口容易被正确使用，不易被误用。</strong></p>
<blockquote>
<p>Make interfaces easy to use correctly and hard to user incorrectly.</p>
</blockquote>
</li>
<li><p><strong>设计「class」如同设计「type」。</strong></p>
<blockquote>
<p>Treat class design as type design.</p>
</blockquote>
</li>
<li><p><strong>宁以「pass-by-reference-to-const」替换「pass-by-value」。</strong></p>
<blockquote>
<p>Prefer pass-by-reference-to-const to pass-by-value.</p>
</blockquote>
</li>
<li><p><strong>必须返回对象时，别妄想返回其「reference」。</strong></p>
<blockquote>
<p>Don’t try to return a reference when you must return an object.</p>
</blockquote>
</li>
<li><p><strong>将成员变量声明为「private」。</strong></p>
<blockquote>
<p>Declare data members private.</p>
</blockquote>
</li>
<li><p><strong>宁以「non-member 且 non-friend 函数」替换「member 函数」。</strong></p>
<blockquote>
<p>Prefer non-member non-friend functions to member functions.</p>
</blockquote>
</li>
<li><p><strong>若所有参数皆需要类型转换，请为此采用「non-member 函数」。</strong></p>
<blockquote>
<p>Declare non-member functions when type conversions should apply to all parameters.</p>
</blockquote>
</li>
<li><p><strong>考虑写出一个不抛出异常的「swap 函数」。</strong></p>
<blockquote>
<p>Consider support for a non-throwing swap.</p>
</blockquote>
</li>
</ol>
<p>一个好的接口，它很容易能被正确使用，并且不易被误用。这是接口设计的最基本思想，我们的设计接口工作总是要围绕着它展开。这一思想包括两方面：</p>
<ul>
<li>「促进正确使用」的方法，包括接口一致性，以及与内置类型的行为进行兼容。</li>
<li>「阻止错误用法」则包括建立新类型、限制类型上的操作、束缚对象的值，以及消除客户的资源管理责任。</li>
</ul>
<p>设计一个 <code>class</code> 要像设计 <code>type</code> 一样，而设计 <code>type</code> 时，我们通常需要进行以下思考：</p>
<ul>
<li>新的 <code>type</code> 应该如何被创建？又如何被销毁？</li>
<li>对象的初始化与赋值之间有何区别？</li>
<li>被「pass-by-value」时，会发生什么？</li>
<li>新 <code>type</code> 的「合法值」是什么？</li>
<li>新 <code>type</code> 需要配合某个「继承图系」吗？</li>
<li>什么样的标准函数需要被驳回？</li>
<li>需要哪些转换？</li>
<li>对于新 <code>type</code> 来说，怎样的操作符以及函数是合理的？</li>
<li>「谁」应该取用新 <code>type</code> 的成员？</li>
<li>什么是「未声明接口」？</li>
<li>这一新 <code>type</code> 有多么一般化？</li>
<li>注意注意注意！你真的真的需要这么一个新的 <code>type</code> 吗？？</li>
</ul>
<p>在函数传参时，我们需要尽量以「pass-by-reference-to-const」替换「pass-by-value」。这是因为前者比较高效，还能够避免「切割问题」（入参为父类，若传入子类，可能只有父类被构造）。注意了，这一条款不是所有情况下都适用的，比如说对于「内置类型」、「STL 迭代器」以及「函数对象」来说，「pass-by-value」才是恰当的选择。</p>
<p>说到将成员变量声明为 <code>private</code>，这一守则很是熟悉了。这么做可以赋予客户访问数据的一致性，能够细微划分访问控制，允诺约束条件获得保证，并且给 <code>class</code> 实现者提供充分的弹性。这里面需要注意的一点是，C++ 中还有一个 <code>protected</code> 关键字，但它并不比 <code>private</code> 更具封装性.从「封装」的角度来看，只存在两种权限，即 <code>private</code> 及其它。</p>
<p><code>std::swap()</code> 函数是个神器，我们在使用「Copy-and-Swap 技术」的时候常常用到它。但它对于我们的自定义类型可能效率不高，这时候我们就应该考虑提供一个自定义类型专用的 <code>swap</code> 函数了，并且这个函数不该抛出异常。我们可以通过对 <code>std::swap()</code> 这一模板函数进行「全特化」来实现我们的客制化需求，但是要注意的是不要往 <code>std</code> 命名空间中加入对它而言全新的东西 —— 我们可以在自己的命名空间进行全特化。</p>
<p>呼，这一章开始有些难度了，涉及到了我未曾接触的知识，或者从未体会过的守则。说明我的实践水平还是太低了。</p>
<p>个人没有理解好的条款是：</p>
<ul>
<li>必须返回对象时，别返回其「reference」。</li>
<li>若所有参数皆需类型转换，请为此采用「non-member 函数」。</li>
</ul>
<p>这两个条款下次要更深入地理解分析。</p>
<p>除此之外，条款 19、23 以及 25，感觉都还未吃透，需要再结合实际代码研究研究。</p>
<h2 id="第五章-「实现」"><a href="#第五章-「实现」" class="headerlink" title="第五章 「实现」"></a>第五章 「实现」</h2><p>上一章是关于「设计」的高效守则，而本章则是进一步到了「实现」的部分。具体实现我们所设计的类、函数时，也有不少需要特别关注的事项，作者将其中一些总结为以下的条款 26~31：</p>
<ol>
<li><p><strong>尽可能延后变量定义式出现的时间。</strong></p>
<blockquote>
<p>Postpone variable definitions as long as possible.</p>
</blockquote>
</li>
<li><p><strong>尽量少做转型动作。</strong></p>
<blockquote>
<p>Minimize casting.</p>
</blockquote>
</li>
<li><p><strong>避免返回「指向对象内部成分的 handle」。</strong></p>
<blockquote>
<p>Avoid returning “handles” to object internals.</p>
</blockquote>
</li>
<li><p><strong>为「异常安全」而努力是值得的。</strong></p>
<blockquote>
<p>Strive for exception-safe code.</p>
</blockquote>
</li>
<li><p><strong>透彻了解「inlining」的里里外外。</strong></p>
<blockquote>
<p>Understand the ins and outs of inlining.</p>
</blockquote>
</li>
<li><p><strong>将文件间的编译一寸关系降至最低。</strong></p>
<blockquote>
<p>Minimize compilation dependencies between files.</p>
</blockquote>
</li>
</ol>
<p>尽可能延后变量定义式出现的时间，直到能够给它初值实参为止。从而避免构造出不必要的对象，以及无意义的默认构造。这样做也能增加程序的清晰度并改善效率。这一守则其实一直都在使用，很好理解。不过文中有一个需要稍微注意的情况就是「循环赋值」，定义式的位置决定了会出现「1 次构造 + 1 次析构 + n 次赋值」，还是「n 次构造 + n 次赋值」，这需要根据实际情况分析效率，再选择最佳的位置。</p>
<p>转型动作在大型工程中几乎是必定会出现的。不过我目前使用的最多的还是 C-style 的转型…就是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> b = (<span class="keyword">float</span>) a;</span><br></pre></td></tr></table></figure>
<p>这已经是「旧式转型」了，而「新式转型」有下面这四种：</p>
<ol>
<li><code>const_cast</code>：常量性转除。</li>
<li><code>dynamic_cast</code>：安全向下转型。</li>
<li><code>reinterpret_cast</code>：低级转型（与编译器有关）。</li>
<li><code>static_cast</code>：强迫隐式转换。</li>
</ol>
<p>需要注意的是，我们应该尽量避免任何转型的出现，特别是在「注重效率」的代码中尽量避免 <code>dynamic_cast</code>。如果转型动作是必要的，我们可以将其隐于某个函数背后，而客户可以调用这一函数并且不用自己手动转型。</p>
<p>由于「新式转型」比较容易辨识，所以我们的转型动作应尽量用它完成。</p>
<p>我们常常通过获取一个「handle（句柄、号码牌）」来保持对某个对象的使用权，或者说是调用途径。一般来说「handle」是一个引用、指针或者迭代器。但使用它时有可能会导致「降低封装性」，因为它可能是「代表对象内部数据」的。并且有这么一种情况，获取「handle」结束时，对象就被析构了（临时对象），此时就会出现「虚吊句柄」的问题。所以我们要尽量避免返回指向对象内部的「handle」，以增强封装性，降低「虚吊句柄」发生的可能性。</p>
<p>「inline 函数」不论怎么看，都像是个普通的函数。但是调用它们并不需要「调用函数」所产生的开销，这一点使得它远远优于利用宏来定义的函数。不过由于它也向宏一样在编译器展开代码，这导致目标代码可能会出现体积膨胀的情况，如果过于膨胀就有可能导致额外的「换页行为」，并且会降低「Cache 击中率」。所以我们需要在合适的情况、恰当的位置使用它。一般我们仅将其用于小型的、被频繁调用的函数。</p>
<p>对于诸如 Android 系统这样庞大的工程来说，将文件间的编译依存关系降至最低这一守则极为重要。平常完全重新编译一个模块都要花费二三十分钟，更别说整机编译的两三个小时，如果不把控好编译依存关系，一个小的文件改动要引发整个模块的重新编译，那将会极大地浪费时间。关于该守则，有一个一般化的构想是：相依于声明式，不要相依于定义式。基于此而出现的两个技术手段分别是「Handle class」与「Interface class」。以及对于程序库的头文件来说，它应以「完全且仅有声明式」的形式存在，这一点对于涉及模板的头文件也适用。</p>
<p>这一章依旧具有一定的难度，特别是：</p>
<ul>
<li>为「异常安全」而努力是值得的。这一条我目前还难以理解，因为鲜少接触相关实践案例。</li>
<li>将文件编译依存关系降至最低。虽然说从书面并且结合日常接触 Android 系统底层编译，让我有了一定的理解，但是我很少能改动或者新增一些头文件或者 <code>makefile</code>，所以理解还是不够深刻，实践时也不知道该从何下手。</li>
</ul>
<p>其它的条款基本上没什么问题，就是关于转型的部分，我还很少使用「新式转型」，这个还需要多动手练习练习。</p>
<h2 id="第六章-「继承与面向对象设计」"><a href="#第六章-「继承与面向对象设计」" class="headerlink" title="第六章 「继承与面向对象设计」"></a>第六章 「继承与面向对象设计」</h2><p>第六章的内容则主要是涉及到了 C++ 的核心，即「面向对象编程（OOP）」部分。作者总结了关于 C++ 的 OOP 中一些常见的疑问，并给出自己的解答，同时也好好地解释了一番 C++ 各种不同特性的真正意义。</p>
<p>回顾一下条款 32~40 的标题：</p>
<ol>
<li><p><strong>确定你的「public 继承」建模出「is-a 关系」。</strong></p>
<blockquote>
<p>Make sure public inheritance models “is-a”.</p>
</blockquote>
</li>
<li><p><strong>避免遮掩继承而来的名称。</strong></p>
<blockquote>
<p>Avoid hiding inherited names.</p>
</blockquote>
</li>
<li><p><strong>区分接口继承和实现继承。</strong></p>
<blockquote>
<p>Differentiate between inheritance of interface and inheritance of implementation.</p>
</blockquote>
</li>
<li><p><strong>考虑「virtual 函数」以外的其它选择。</strong></p>
<blockquote>
<p>Consider alternatives to virtual functions.</p>
</blockquote>
</li>
<li><p><strong>绝不重新定义继承而来的「non-virtual 函数」。</strong></p>
<blockquote>
<p>Never redefine an inherited non-virtual function.</p>
</blockquote>
</li>
<li><p><strong>绝不重新定义继承而来的缺省参数值。</strong></p>
<blockquote>
<p>Never redefine a function’s inherited default parameter value.</p>
</blockquote>
</li>
<li><p><strong>通过「复合」建模出「has-a 关系」或「根据某物实现出」。</strong></p>
<blockquote>
<p>Model “has-a” or “is-implemented-in-terms-of” through composition.</p>
</blockquote>
</li>
<li><p><strong>明智而审慎地使用「private 继承」。</strong></p>
<blockquote>
<p>Use private inheritance judiciously.</p>
</blockquote>
</li>
<li><p><strong>明智而审慎地使用「多重继承」。</strong></p>
<blockquote>
<p>Use multiple inheritance judiciously.</p>
</blockquote>
</li>
</ol>
<p>「public 继承」代表着什么？没错，是「is-a」关系，B 继承了 A，则「B 是一个 A」就应该成立，而适用于 A 的每一件事也都要适用于 B。<br>我们在设计继承关系时一定要考虑好这一点，因为某些常识性的东西可能会让我们混淆这一概念。比如说对于「鸟类」，我们通常认为「鸟会飞」，如果「鸟类」作为基类，则继承于此的所有类都应该有「飞」这一动作。但是问题来了，现实中「企鹅」也属于鸟类，但它「不会飞」！所以如果需要设计一个「企鹅类」，则它不应该继承于「鸟类」。</p>
<p>「变量遮掩」问题不止在继承关系中会出现。最早接触到这一问题应该是与「作用域」有关：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">// Global var</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// Local var</span></span><br><span class="line">    x = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很典型，<code>func</code> 函数中定义的局部变量 <code>x</code> 在「函数内部」覆盖住了全局变量 <code>x</code>，如果 <code>x = a</code> 这一语句原本是想对全局的 <code>x</code> 进行操作，那么这段代码就无法达到预期效果了。这说明了一点：我们使用变量时，是从局部开始，往全局方向进行查找的。</p>
<p>而在类继承关系中，子类的函数、变量名称与父类中相同，则会造成遮掩。此时我们可能就无法调用父类的 <code>public</code> 函数，这与预期不符。所以在设计与实现子类时一定要注意，不要对父类造成遮掩。如果已经造成遮掩，则需要采用「using 声明式」或「转交函数」来让其重见天日。</p>
<p>作者分析，<code>public</code> 继承概念是由两部分组成：「函数接口继承」与「函数实现继承」，它们是不一样的。</p>
<p>那么这两种继承是怎么回事？可以通过这几种函数大致了解其含义：</p>
<ul>
<li>父类中声明了的「纯虚函数」，仅仅具体指定了接口继承（父类不一定有实现），子类必须独立实现这一接口。</li>
<li>「虚函数」则指定了接口继承以及缺省的实现继承（父类的实现）。</li>
<li>「非虚函数」具体指定了接口继承，并且还强制性进行了实现继承。</li>
</ul>
<p>说到「非虚函数」的继承，我们应该要注意一点，即绝不能在子类重新定义它。因为有如下的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D x;</span><br><span class="line">    B* pB = &amp;x;</span><br><span class="line">    D* pD = &amp;x;</span><br><span class="line">    </span><br><span class="line">    pB-&gt;mf(); <span class="comment">// Call B::mf()</span></span><br><span class="line">    pD-&gt;mf(); <span class="comment">// Call D::mf()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，两个对 <code>mf()</code> 的调用对应到了不同的函数中。这不是我们预期的结果，至少在多态的情况下。</p>
<p>而对于「虚函数」，我们绝不能在子类重定义继承而来的缺省参数值。因为「虚函数」是「动态绑定」的，而缺省参数却是「静态绑定」的，这会导致什么情况呢？我在父类 A 中这样声明了虚函数 <code>darw(Color c = Color::red);</code>，然后再在子类 B 中声明 <code>darw(Color c = Color::green);</code>，当我们用一个 A 类指针指向一个 B 对象，再调用 <code>darw</code> 函数时，就会出现「调用了 B 类的具体实现，却使用了 A 类的默认参数」这种超出预期的效果。</p>
<p>「复合关系」与继承是完全不同的概念。「复合」又称为聚合、内嵌、分层、内含等，这是一种「has-a 关系」（在应用域），或者「根据某物实现出」（在实现域）。一个简单的例子可以解释这一关系：考虑需要通过 <code>std::list</code> 来实现一个 <code>Set</code> 类。我们不能通过继承 <code>std::list</code> 来实现，因为 <code>Set</code> 不是一个 <code>List</code>。此时我们就可以在 <code>Set</code> 内部设定一个 <code>std::list</code> 类型的成员，通过它来实现 <code>Set</code> 的种种操作，这就是「has-a 关系」。</p>
<p>使用「private 继承」时需要小心谨慎。与复合不同，它有着「对象尺寸最小化」的效果。一般来说它的级别比复合低，但是如果子类需要访问父类的 <code>protected</code> 成员，或者需要重定义继承而来的虚函数时，使用它也是合理的。</p>
<p>同样地，「多重继承」能力在使用时也是需要非常谨慎的。它可能会导致新的歧义，以及对「virtual 继承」的需要，而「virtual 继承」会增加大小、速度、初始化及赋值复杂度等的成本。最适合使用「virtual 继承」的情况则是该基类不带有任何数据时。虽然「多重继承」比较复杂且会带来不少麻烦，但它确实有其正当用途，比如「public 继承某接口类」的同时还要「private 继承某个协助实现的类」的情况。</p>
<p>这一章看得我脑子有点乱，「继承」是一个非常强大的特性，但是它经常给我带来代码阅读与理解上的困扰。</p>
<p>觉得比较难以理解消化的条款就是：</p>
<ul>
<li>考虑「virtual 函数」以外的选择。</li>
<li>明智而审慎地使用「private 继承」。</li>
<li>明智而审慎地使用「多重继承」。</li>
</ul>
<p>之后需要继续结合实践，深入研究体会。</p>
<h2 id="第七章-「模板与泛型编程」"><a href="#第七章-「模板与泛型编程」" class="headerlink" title="第七章 「模板与泛型编程」"></a>第七章 「模板与泛型编程」</h2><p>第七章进入了 C++ 模板的领域。一开始，模板的出现是为了让我们得以建立「类型安全」的容器，比如 <code>vector</code>、<code>list</code> 以及 <code>map</code>。后来人们渐渐发现模板具有非常强大的能力，甚至它本身就是一部完整的「图灵机」（可以被用来计算任何可计算的值）。模板的应用非常宽广，但作者总结出了一组支撑起所有模板编程的核心观念：</p>
<ol>
<li><p><strong>了解隐式接口和编译期多态。</strong></p>
<blockquote>
<p>Understand implicit interfaces and compile-time polymorphism.</p>
</blockquote>
</li>
<li><p><strong>了解「typename」的双重意义。</strong></p>
<blockquote>
<p>Understand the two meanings of typename.</p>
</blockquote>
</li>
<li><p><strong>学习处理「模板化基类」内的名称。</strong></p>
<blockquote>
<p>Know how to access names in templatized base classes.</p>
</blockquote>
</li>
<li><p><strong>将与参数无关的代码从模板中抽离。</strong></p>
<blockquote>
<p>Factor parameter-independent code out of templates.</p>
</blockquote>
</li>
<li><p><strong>运用成员函数模板接受所有兼容类型。</strong></p>
<blockquote>
<p>Use member function templates to accept “all compatible types”.</p>
</blockquote>
</li>
<li><p><strong>需要类型转换时请为模板定义非成员函数。</strong></p>
<blockquote>
<p>Define non-member functions inside templates when type conversion are desired.</p>
</blockquote>
</li>
<li><p><strong>请使用「traits classes」表现类型信息。</strong></p>
<blockquote>
<p>Use traits classes for information about types.</p>
</blockquote>
</li>
<li><p><strong>认识「template 元编程」。</strong></p>
<blockquote>
<p>Be aware of template metaprogramming.</p>
</blockquote>
</li>
</ol>
<p>关于隐式接口与编译期多态，可以通过对比「模板」与「类」来大致地理解：</p>
<ul>
<li>对于「模板」参数而言，接口是隐式的，它奠基于有效表达式。而多态则是通过「模板具现化」与「函数重载解析」发生于编译期。</li>
<li>对于「类」来说，接口是显式的，它以函数签名为中心。其多态是通过「虚函数」发生于运行期。</li>
</ul>
<p><code>typename</code> 具有双重意义。首先要知道的是，模板参数声明中的 <code>class</code> 与 <code>typename</code> 是一样的，可以随意互换。其次，对于嵌套从属类型名称，比如有这么个语句 <code>Base&lt;T&gt;::Nested temp;</code>，编译器并不知道这是一个类，所以我们需要修改语句为 <code>typename Base&lt;T&gt;Nested temp;</code>，这样才能通过编译。不过注意，在「成员初值列」与「基类列」中不能使用 <code>typename</code>。</p>
<p>将与模板参数无关的代码从模板中抽离，否则可能会产生我们所不愿看到的代码膨胀问题：</p>
<ul>
<li>对于「非类型模板参数」造成的膨胀往往可以消除。其方法是以函数参数或者类成员变量来替换这一模板参数。</li>
<li>对于「类型模板参数」造成的代码膨胀通常可以降低其影响。其方法是让带有完全相同二进制表述的具现类型来共享实现码。</li>
</ul>
<p>运用成员函数模板接受所有兼容的类型，一个关键示例是「泛化拷贝构造函数」：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&amp; other); <span class="comment">// Note</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就能实现对各种类型的兼容，但需要注意的是，我们声明这样的泛化成员函数时，我们还需要同时声明一个正常的相应函数。</p>
<p>「Traits」允许你在编译期间取得某些「类型相关信息」。它是一种技术，也是一个 C++ 程序员共同遵守的协议。将其与「重载技术」进行整合后，「Traits class」就有可能在编译期对类型执行 <code>if.else.</code> 测试。</p>
<p>最后作者提到了「模板元编程」技术，说实话，没怎么看懂……</p>
<p>阅读这一章搞得我脑壳疼，因为本身就太少实践模板技术，平常看代码时也没有深入分析模板的妙处，因为它简单的地方太容易理解，而难的地方又实在是很难……总之我是觉得，模板技术固然强大，但它大大降低了代码的可读性……</p>
<p>难以理解的条款太多了：</p>
<ul>
<li>学习处理「模板化基类」的名称。</li>
<li>需要类型转换时请为模板定义非成员函数。</li>
<li>请使用「Traits class」表现类型信息。</li>
<li>认识「模板元编程」。</li>
</ul>
<p>看来下一阶段要好好攻克模板技术了。</p>
<h2 id="第八章-「定制-new-和-delete」"><a href="#第八章-「定制-new-和-delete」" class="headerlink" title="第八章 「定制 new 和 delete」"></a>第八章 「定制 new 和 delete」</h2><p>第八章就不用说了，并没有看，因为目前完全没碰到过这些情况……</p>
<ol>
<li><p><strong>了解「new-handler」的行为。</strong></p>
<blockquote>
<p>Understand the behavior of the new-handler.</p>
</blockquote>
</li>
<li><p><strong>了解「new 与 delete」的合理替换时机。</strong></p>
<blockquote>
<p>Understand when it makes sense to replace new and delete.</p>
</blockquote>
</li>
<li><p><strong>编写「new 和 delete」时需固守常规。</strong></p>
<blockquote>
<p>Adhere to convention when writing new and delete.</p>
</blockquote>
</li>
<li><p><strong>写了「placement new」也要写「placement delete」。</strong></p>
<blockquote>
<p>Write placement delete if you write placement new.</p>
</blockquote>
</li>
</ol>
<h2 id="第九章-「杂项讨论」"><a href="#第九章-「杂项讨论」" class="headerlink" title="第九章 「杂项讨论」"></a>第九章 「杂项讨论」</h2><p>第九章也没有详细看，TR1 和 Boost 基本上没有接触，虽然作者表示用起来会很高效。毕竟现在都只是在做 Android 系统底层的开发，这两个东西也没法用啊…</p>
<ol>
<li><p><strong>不要轻忽编译器的警告。</strong></p>
<blockquote>
<p>Pay attention to compiler warnings.</p>
</blockquote>
</li>
<li><p><strong>让自己熟悉包括「TR1」在内的标准程序库。</strong></p>
<blockquote>
<p>Familiarize yourself with the standard library, including TR1.</p>
</blockquote>
</li>
<li><p><strong>让自己熟悉「Boost」。</strong></p>
<blockquote>
<p>Familiarize yourself with Boost.</p>
</blockquote>
</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过回顾这些内容，我发现我对这本书的了解可能还不到六成。</p>
<p>抛开暂时不管的最后两章。其它章节中，只有前三章做到了每一条目都能好好理解掌握，之后的几章就开始逐渐遇到困难。特别是到了模板的部分，啃起来就像是在啃石头一样。</p>
<p>功力尚浅，功力尚浅啊！</p>
<p>果然工作这一年来，我写的代码还是太少了。虽说业务上都是在改 Android 底层的源码，或者在这上面加些代码，能亲自实践的面太窄，根本没有体会过一整套软件系统的构建过程。但是这些业务不触及的部分，我在业余时间也没有好好钻研，我个人的懒惰问题也是不容忽视的啊。</p>
<p>接下来一定要好好针对弱项补课，希望在下一次阅读这本书的时候，现在难理解的这些项都能被攻克。</p>
<h2 id="最后叨比几句"><a href="#最后叨比几句" class="headerlink" title="最后叨比几句"></a>最后叨比几句</h2><p>最近一直在想，为什么当时签约时发现到公司规定本届应届生一年半内不给涨工资，而且开价也不高，但我还是来了。</p>
<p>因为我 TM 没得选啊！能力太差，菜是原罪！</p>
<p>「当你抱怨你的待遇和环境不好时，先想想你为什么会在这里。」</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程技术/" rel="tag"># 编程技术</a>
          
            <a href="/tags/温故知新/" rel="tag"># 温故知新</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/01/Stone-2017-Summarize/" rel="next" title="[石头 · 记] 一小段人生总结">
                <i class="fa fa-chevron-left"></i> [石头 · 记] 一小段人生总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/17/BuyIpadPro/" rel="prev" title="[剁手] 初体验 —— ipad pro + apple pencil">
                [剁手] 初体验 —— ipad pro + apple pencil <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/Second_avatar.png"
                alt="StoneDemo" />
            
              <p class="site-author-name" itemprop="name">StoneDemo</p>
              <p class="site-description motion-element" itemprop="description">慵懒的两只程序猿</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="mailto:714781902@qq.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/qq_16775897" target="_blank" title="CSDN" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>CSDN</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.linkedin.com/in/%E5%9E%92%E5%A2%85-%E7%9F%B3-2a3720144/" target="_blank" title="Linkedin" rel="external nofollow"><i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.instagram.com/stone.demo/" target="_blank" title="Instagram" rel="external nofollow"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#温故而知新"><span class="nav-number">2.</span> <span class="nav-text">温故而知新</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-「让自己习惯-C-」"><span class="nav-number">2.1.</span> <span class="nav-text">第一章 「让自己习惯 C++」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-「构造、析构、赋值运算」"><span class="nav-number">2.2.</span> <span class="nav-text">第二章 「构造、析构、赋值运算」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-「资源管理」"><span class="nav-number">2.3.</span> <span class="nav-text">第三章 「资源管理」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-「设计与声明」"><span class="nav-number">2.4.</span> <span class="nav-text">第四章 「设计与声明」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-「实现」"><span class="nav-number">2.5.</span> <span class="nav-text">第五章 「实现」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-「继承与面向对象设计」"><span class="nav-number">2.6.</span> <span class="nav-text">第六章 「继承与面向对象设计」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-「模板与泛型编程」"><span class="nav-number">2.7.</span> <span class="nav-text">第七章 「模板与泛型编程」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八章-「定制-new-和-delete」"><span class="nav-number">2.8.</span> <span class="nav-text">第八章 「定制 new 和 delete」</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-「杂项讨论」"><span class="nav-number">2.9.</span> <span class="nav-text">第九章 「杂项讨论」</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">3.</span> <span class="nav-text">后记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.1.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后叨比几句"><span class="nav-number">3.2.</span> <span class="nav-text">最后叨比几句</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate"> 
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StoneDemo</span>

  

  
</div>


  



  <div class="powered-by">Powered by <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Wechat,QQZone,Evernote";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.1.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.1.0"></script>


  

  

</body>
</html>
